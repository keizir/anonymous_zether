{
  "contractName": "ERC20Interface",
  "abi": [
    {
      "constant": false,
      "inputs": [
        {
          "name": "to",
          "type": "address"
        },
        {
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": false,
      "inputs": [
        {
          "name": "from",
          "type": "address"
        },
        {
          "name": "to",
          "type": "address"
        },
        {
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "metadata": "",
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "sourceMap": "",
  "deployedSourceMap": "",
  "source": "pragma solidity 0.5.4;\n\nimport './ZetherVerifier.sol';\nimport './BurnVerifier.sol';\n\ncontract ERC20Interface {\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n}\n\ncontract ZSC {\n    ERC20Interface coin;\n    ZetherVerifier zetherverifier;\n    BurnVerifier burnverifier;\n    uint256 public epochLength; // now in milliseconds.\n\n    uint256 bTotal = 0; // could use erc20.balanceOf(this), but (even pure / view) calls cost gas during EVM execution\n    uint256 constant MAX = 4294967295; // 2^32 - 1 // no sload for constants...!\n    mapping(bytes32 => bytes32[2][2]) acc; // main account mapping\n    mapping(bytes32 => bytes32[2][2]) pTransfers; // storage for pending transfers\n    mapping(bytes32 => address) ethAddrs;\n    mapping(bytes32 => uint256) lastRollOver;\n    bytes32[] nonceSet; // would be more natural to use a mapping, but they can't be deleted / reset!\n    uint256 lastGlobalUpdate = 0; // will be also used as a proxy for \"current epoch\", seeing as rollovers will be anticipated\n    // not implementing account locking for now...revisit\n\n    event RegistrationOccurred(); // no more args: that the transaction occurred and was not modified (including replays)\n    event FundOccurred(); // can be determined on the basis of the transaction hash alone. (sig is included in hash)\n    event TransferOccurred(bytes32[2][] parties); // all parties will be notified, client can determine whether it was real or not.\n    // arg is still necessary for transfers---not even so much to know when you received a transfer, as to know when you got rolled over.\n    event BurnOccurred();\n\n    constructor(address _coin, address _zether, address _burn, uint256 _epochLength) public {\n        coin = ERC20Interface(_coin);\n        zetherverifier = ZetherVerifier(_zether);\n        burnverifier = BurnVerifier(_burn);\n        epochLength = _epochLength;\n    }\n\n    function simulateAccounts(bytes32[2][] calldata y, uint256 epoch) view external returns (bytes32[2][2][] memory accounts) {\n        // all of this could be assembled locally by querying `acc` and `pTransfers` (and `lastRollOver`) and assembling things by hand\n        // turns out this is extremely _slow_ though, because of the ~ 4 * N queries which must be made. turns out it's much faster\n        // to simply move the entire process into a contract method, and in fact this allows us to make the above 3 private\n        uint256 size = y.length;\n        accounts = new bytes32[2][2][](size);\n        for (uint256 i = 0; i < size; i++) {\n            bytes32 yHash = keccak256(abi.encodePacked(y[i]));\n            accounts[i] = acc[yHash];\n            if (lastRollOver[yHash] < epoch) {\n                bytes32[2][2] memory scratch = pTransfers[yHash];\n                assembly {\n                    let result := 1\n                    let m := mload(0x40)\n                    mstore(m, mload(mload(scratch)))\n                    mstore(add(m, 0x20), mload(add(mload(scratch), 0x20)))\n                    mstore(add(m, 0x40), mload(mload(mload(add(add(accounts, 0x20), mul(i, 0x20))))))\n                    mstore(add(m, 0x60), mload(add(mload(mload(add(add(accounts, 0x20), mul(i, 0x20)))), 0x20)))\n                    result := and(result, staticcall(gas, 0x06, m, 0x80, mload(mload(add(add(accounts, 0x20), mul(i, 0x20)))), 0x40))\n                    mstore(m, mload(mload(add(scratch, 0x20))))\n                    mstore(add(m, 0x20), mload(add(mload(add(scratch, 0x20)), 0x20)))\n                    mstore(add(m, 0x40), mload(mload(add(mload(add(add(accounts, 0x20), mul(i, 0x20))), 0x20))))\n                    mstore(add(m, 0x60), mload(add(mload(add(mload(add(add(accounts, 0x20), mul(i, 0x20))), 0x20)), 0x20)))\n                    result := and(result, staticcall(gas, 0x06, m, 0x80, mload(add(mload(add(add(accounts, 0x20), mul(i, 0x20))), 0x20)), 0x40))\n                    if iszero(result) {\n                        revert(0, 0)\n                    }\n                }\n            }\n        }\n    }\n\n    function rollOver(bytes32 yHash) internal {\n        uint256 e = block.timestamp / 1000000 / epochLength; // can block.timestamp be \"gamed\"?\n        // https://github.com/ethereum/wiki/blob/c02254611f218f43cbb07517ca8e5d00fd6d6d75/Block-Protocol-2.0.md\n        // note that block.timestamp is technically in _nanoseconds_, although its trailing 3 digits are always 0 (so really micro)\n        if (lastRollOver[yHash] < e) {\n            bytes32[2][2][2] memory scratch = [acc[yHash], pTransfers[yHash]];\n            assembly {\n                let result := 1\n                let m := mload(0x40)\n                mstore(m, mload(mload(mload(scratch))))\n                mstore(add(m, 0x20), mload(add(mload(mload(scratch)), 0x20)))\n                mstore(add(m, 0x40), mload(mload(mload(add(scratch, 0x20)))))\n                mstore(add(m, 0x60), mload(add(mload(mload(add(scratch, 0x20))), 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(mload(scratch)), 0x40))\n                mstore(m, mload(mload(add(mload(scratch), 0x20))))\n                mstore(add(m, 0x20), mload(add(mload(add(mload(scratch), 0x20)), 0x20)))\n                mstore(add(m, 0x40), mload(mload(add(mload(add(scratch, 0x20)), 0x20))))\n                mstore(add(m, 0x60), mload(add(mload(add(mload(add(scratch, 0x20)), 0x20)), 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(add(mload(scratch), 0x20)), 0x40))\n                if iszero(result) {\n                    revert(0, 0)\n                }\n            }\n            acc[yHash] = scratch[0];\n            pTransfers[yHash] = [[bytes32(0), bytes32(0)], [bytes32(0), bytes32(0)]];\n            lastRollOver[yHash] = e;\n        }\n        if (lastGlobalUpdate < e) {\n            lastGlobalUpdate = e;\n            delete nonceSet;\n        }\n    }\n\n    function register(bytes32[2] calldata y) external { // keeping this as is\n        bytes32 yHash = keccak256(abi.encodePacked(y));\n        bytes32[2][2] memory scratch = acc[yHash];\n        require((scratch[0][0] | scratch[0][1] | scratch[1][0] | scratch[1][1]) == 0x00, \"Account already registered.\");\n        ethAddrs[yHash] = msg.sender; // eth address will be _permanently_ bound to y\n        // warning: front-running danger. client should verify that he was not front-run before depositing funds to y!\n        assembly {\n            calldatacopy(mload(scratch), 0x04, 0x40) // copy contents of y to first inner array of scratch\n            mstore(mload(add(scratch, 0x20)), 0x077da99d806abd13c9f15ece5398525119d11e11e9836b2ee7d23f6159ad87d4)\n            mstore(add(mload(add(scratch, 0x20)), 0x20), 0x01485efa927f2ad41bff567eec88f32fb0a0f706588b4e41a8d587d008b7f875)\n            // account of y is now [y, g] = ElG_y(e, 1). sentinel for having registered\n        }\n        acc[yHash] = scratch;\n        emit RegistrationOccurred(); // client must use this event callback to confirm.\n    }\n\n    function fund(bytes32[2] calldata y, uint256 bTransfer) external {\n        bytes32 yHash = keccak256(abi.encodePacked(y));\n        rollOver(yHash);\n\n        // registration check here would be redundant, as any `transferFrom` the 0 address will necessarily fail. save an sload\n        require(bTransfer <= MAX, \"Deposit amount out of range.\"); // uint, so other way not necessary?\n        require(bTransfer + bTotal <= MAX, \"Fund pushes contract past maximum value.\");\n        // if pTransfers[yHash] == [0, 0, 0, 0] then an add and a write will be equivalent...\n        bytes32[2] memory scratch = pTransfers[yHash][0];\n        // won't let me assign this array using literals / casts\n        assembly {\n            let m := mload(0x40)\n            let result := 1\n            mstore(m, mload(scratch))\n            mstore(add(m, 0x20), mload(add(scratch, 0x20)))\n            mstore(add(m, 0x40), 0x077da99d806abd13c9f15ece5398525119d11e11e9836b2ee7d23f6159ad87d4)\n            mstore(add(m, 0x60), 0x01485efa927f2ad41bff567eec88f32fb0a0f706588b4e41a8d587d008b7f875)\n            mstore(add(m, 0x80), bTransfer) // b will hopefully be a primitive / literal and not a pointer / address?\n            result := and(result, staticcall(gas, 0x07, add(m, 0x40), 0x60, add(m, 0x40), 0x40))\n            result := and(result, staticcall(gas, 0x06, m, 0x80, scratch, 0x40))\n            if iszero(result) {\n                revert(0, 0)\n            }\n        }\n        pTransfers[yHash][0] = scratch;\n        require(coin.transferFrom(ethAddrs[yHash], address(this), bTransfer), \"Transfer from sender failed.\");\n        // front-running here would be disadvantageous, but still prevent it here by using ethAddrs[yHash] instead of msg.sender\n        // also adds flexibility: can later issue messages from arbitrary ethereum accounts.\n        bTotal += bTransfer;\n        emit FundOccurred();\n    }\n\n    function transfer(bytes32[2][] memory L, bytes32[2] memory R, bytes32[2][] memory y, bytes32[2] memory u, bytes memory proof) public {\n        uint256 size = y.length;\n        bytes32[2][] memory CLn = new bytes32[2][](size);\n        bytes32[2][] memory CRn = new bytes32[2][](size);\n        require(L.length == size, \"Input array length mismatch!\");\n        uint256 result = 1;\n        for (uint256 i = 0; i < y.length; i++) {\n            bytes32 yHash = keccak256(abi.encodePacked(y[i]));\n            rollOver(yHash);\n            bytes32[2][2] memory scratch = pTransfers[yHash];\n            assembly {\n                let m := mload(0x40)\n                mstore(m, mload(mload(scratch)))\n                mstore(add(m, 0x20), mload(add(mload(scratch), 0x20)))\n                // calldatacopy(add(m, 0x40), add(0x104, mul(i, 0x40)), 0x40) // copy L[i] onto running block\n                // having to change external --> public to avoid stacktoodeep\n                // as a result, have to use the below two lines instead of the above single line.\n                mstore(add(m, 0x40), mload(mload(add(add(L, 0x20), mul(i, 0x20)))))\n                mstore(add(m, 0x60), mload(add(mload(add(add(L, 0x20), mul(i, 0x20))), 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(scratch), 0x40))\n                mstore(m, mload(mload(add(scratch, 0x20))))\n                mstore(add(m, 0x20), mload(add(mload(add(scratch, 0x20)), 0x20)))\n                // calldatacopy(add(m, 0x40), 0x24, 0x40) // copy R onto running block\n                mstore(add(m, 0x40), mload(R))\n                mstore(add(m, 0x60), mload(add(R, 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(add(scratch, 0x20)), 0x40))\n            }\n            pTransfers[yHash] = scratch; // credit / debit / neither y's account.\n            scratch = acc[yHash];\n            assembly {\n                let m := mload(0x40)\n                mstore(m, mload(mload(scratch)))\n                mstore(add(m, 0x20), mload(add(mload(scratch), 0x20)))\n                mstore(add(m, 0x40), mload(mload(add(add(L, 0x20), mul(i, 0x20)))))\n                mstore(add(m, 0x60), mload(add(mload(add(add(L, 0x20), mul(i, 0x20))), 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(add(add(CLn, 0x20), mul(i, 0x20))), 0x40))\n                mstore(m, mload(mload(add(scratch, 0x20))))\n                mstore(add(m, 0x20), mload(add(mload(add(scratch, 0x20)), 0x20)))\n                mstore(add(m, 0x40), mload(R))\n                mstore(add(m, 0x60), mload(add(R, 0x20)))\n                result := and(result, staticcall(gas, 0x06, m, 0x80, mload(add(add(CRn, 0x20), mul(i, 0x20))), 0x40))\n            }\n        }\n        require(result == 1, \"Elliptic curve operations failure. Bad points?\");\n\n        // warning: no check that recipients are registered accounts, i.e., that _every_ y has been registered to.\n        // make sure that you register your eth account to your pubkey before receiving funds (unless you're using a throwaway, see below).\n        // if you don't, your registration could be pre-empted by an adversary, necessitating that you further transfer before withdrawing\n        // if this pre-empt goes unnoticed, and the further transfer is _not_ taken prior to withdrawal, then you'll lose funds\n        // this is a design decision: could require everyone to be registered...? but this would dampen anonymity a bit. i.e., throwaways\n        // it would be more convenient to not have to register a (new, random) eth account to each throwaway you make.\n        // sure, an adversary could latch on to your throwaway, but you were going to transfer it back to your main account anyway, so who cares?\n        // thus the burden is thus now on you, the _recipient_, to make sure you (successfully) register before receiving funds,\n        // and if you don't and re pre-empted / front-run, to _notice_ and to transfer to a new account before withdrawing\n        // this won't be an issue in practice, as the client software will _force_ you to register right away when your public key is generated,\n        // and will notify you if the process is compromised.\n\n        bool seen = false;\n        bytes32 uHash = keccak256(abi.encodePacked(u));\n        for (uint256 i = 0; i < nonceSet.length; i++) {\n            if (nonceSet[i] == uHash) {\n                seen = true;\n                break;\n            }\n        }\n        require(!seen, \"Nonce already seen!\");\n        if (size > zetherverifier.baseSize()) {\n            zetherverifier.extendBase(size);\n        }\n        require(zetherverifier.verifyTransfer(CLn, CRn, L, R, y, lastGlobalUpdate, u, proof), \"Transfer proof verification failed!\");\n\n        nonceSet.push(uHash);\n        emit TransferOccurred(y);\n    }\n\n    function burn(bytes32[2] memory y, uint256 bTransfer, bytes32[2] memory u, bytes memory proof) public {\n        bytes32 yHash = keccak256(abi.encodePacked(y));\n        rollOver(yHash);\n\n        require(ethAddrs[yHash] != address(0), \"Unregistered account!\"); // not necessary for safety, but will prevent accidentally withdrawing to the 0 address\n        require(0 <= bTransfer && bTransfer <= MAX, \"Transfer amount out of range.\");\n        bytes32[2][2] memory scratch = pTransfers[yHash]; // could technically use sload, but... let's not go there.\n        assembly {\n            let result := 1\n            let m := mload(0x40)\n            mstore(m, mload(mload(scratch)))\n            mstore(add(m, 0x20), mload(add(mload(scratch), 0x20)))\n            // load bulletproof generator here\n            mstore(add(m, 0x40), 0x077da99d806abd13c9f15ece5398525119d11e11e9836b2ee7d23f6159ad87d4) // g_x\n            mstore(add(m, 0x60), 0x01485efa927f2ad41bff567eec88f32fb0a0f706588b4e41a8d587d008b7f875) // g_y\n            mstore(add(m, 0x80), sub(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001, bTransfer))\n            result := and(result, staticcall(gas, 0x07, add(m, 0x40), 0x60, add(m, 0x40), 0x40))\n            result := and(result, staticcall(gas, 0x06, m, 0x80, mload(scratch), 0x40)) // scratch[0] = acc[yHash][0] * g ^ -b, scratch[1] doesn't change\n            if iszero(result) {\n                revert(0, 0)\n            }\n        }\n        pTransfers[yHash] = scratch; // debit y's balance\n        scratch = acc[yHash]; // simulate debit of acc---just for use in verification, won't be applied\n        assembly {\n            let result := 1\n            let m := mload(0x40)\n            mstore(m, mload(mload(scratch)))\n            mstore(add(m, 0x20), mload(add(mload(scratch), 0x20)))\n            mstore(add(m, 0x40), 0x077da99d806abd13c9f15ece5398525119d11e11e9836b2ee7d23f6159ad87d4) // g_x\n            mstore(add(m, 0x60), 0x01485efa927f2ad41bff567eec88f32fb0a0f706588b4e41a8d587d008b7f875) // g_y\n            mstore(add(m, 0x80), sub(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001, bTransfer))\n            result := and(result, staticcall(gas, 0x07, add(m, 0x40), 0x60, add(m, 0x40), 0x40))\n            result := and(result, staticcall(gas, 0x06, m, 0x80, mload(scratch), 0x40)) // scratch[0] = acc[yHash][0] * g ^ -b, scratch[1] doesn't change\n            if iszero(result) {\n                revert(0, 0)\n            }\n        }\n        bool seen = false;\n        bytes32 uHash = keccak256(abi.encodePacked(u));\n        for (uint256 i = 0; i < nonceSet.length; i++) {\n            if (nonceSet[i] == uHash) { // does this have to repeat the sload for each iteration?!? revisit\n                seen = true;\n                break;\n            }\n        }\n        require(!seen, \"Nonce already seen!\");\n        require(burnverifier.verifyBurn(scratch[0], scratch[1], y, bTransfer, lastGlobalUpdate, u, proof), \"Burn proof verification failed!\");\n        require(coin.transfer(ethAddrs[yHash], bTransfer), \"This shouldn't fail... Something went severely wrong.\");\n        // note: change from Zether spec. should use bound address not msg.sender, to prevent \"front-running attack\".\n        bTotal -= bTransfer;\n        nonceSet.push(uHash);\n        emit BurnOccurred();\n    }\n}\n",
  "sourcePath": "/Users/benediamond/anonymous-zether/contracts/ZSC.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.9",
  "updatedAt": "2019-05-14T19:15:17.922Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}