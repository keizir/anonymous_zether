{
  "contractName": "Utils",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.4+commit.9549d8ff\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol\":\"Utils\"},\"evmVersion\":\"byzantium\",\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol\":{\"keccak256\":\"0x8042a21e0d68964297468f01088773705e013ec436f4ef23f2c6221837c96a33\",\"urls\":[\"bzzr://c61c9573ebc7bd5f9c81065894fcbf255e2a66550dc82a31348fdf9c4b4d42fe\"]}},\"version\":1}",
  "bytecode": "0x605a602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a7230582072db45f27f724187f2dd886faf5669813ddc73a396174dc8abc6b48d550ddfa46c6578706572696d656e74616cf50037",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a7230582072db45f27f724187f2dd886faf5669813ddc73a396174dc8abc6b48d550ddfa46c6578706572696d656e74616cf50037",
  "sourceMap": "58:4492:4:-;;132:2:-1;166:7;155:9;146:7;137:37;252:7;246:14;243:1;238:23;232:4;229:33;270:1;265:20;;;;222:63;;265:20;274:9;222:63;;298:9;295:1;288:20;328:4;319:7;311:22;352:7;343;336:24",
  "deployedSourceMap": "58:4492:4:-;;;;;;;;",
  "source": "pragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nlibrary Utils {\n\n    uint256 constant GROUP_ORDER = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant FIELD_ORDER = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\n        return addmod(x, y, GROUP_ORDER);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulmod(x, y, GROUP_ORDER);\n    }\n\n    function inv(uint256 x) internal view returns (uint256) {\n        return exp(x, GROUP_ORDER - 2);\n    }\n\n    function mod(uint256 x) internal pure returns (uint256) {\n        return x % GROUP_ORDER;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x - y : GROUP_ORDER - y + x;\n    }\n\n    function neg(uint256 x) internal pure returns (uint256) {\n        return GROUP_ORDER - x;\n    }\n\n    function exp(uint256 base, uint256 exponent) internal view returns (uint256 output) {\n        uint256 order = GROUP_ORDER;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), 0x20)\n            mstore(add(m, 0x40), 0x20)\n            mstore(add(m, 0x60), base)\n            mstore(add(m, 0x80), exponent)\n            mstore(add(m, 0xa0), order)\n            if iszero(staticcall(gas, 0x05, m, 0xc0, m, 0x20)) { // staticcall or call?\n                revert(0, 0)\n            }\n            output := mload(m)\n        }\n    }\n\n    function fieldExp(uint256 base, uint256 exponent) internal view returns (uint256 output) { // warning: mod p, not q\n        uint256 order = FIELD_ORDER;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), 0x20)\n            mstore(add(m, 0x40), 0x20)\n            mstore(add(m, 0x60), base)\n            mstore(add(m, 0x80), exponent)\n            mstore(add(m, 0xa0), order)\n            if iszero(staticcall(gas, 0x05, m, 0xc0, m, 0x20)) { // staticcall or call?\n                revert(0, 0)\n            }\n            output := mload(m)\n        }\n    }\n\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    function add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(p1))\n            mstore(add(m, 0x20), mload(add(p1, 0x20)))\n            mstore(add(m, 0x40), mload(p2))\n            mstore(add(m, 0x60), mload(add(p2, 0x20)))\n            if iszero(staticcall(gas, 0x06, m, 0x80, r, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(p))\n            mstore(add(m, 0x20), mload(add(p, 0x20)))\n            mstore(add(m, 0x40), s)\n            if iszero(staticcall(gas, 0x07, m, 0x60, r, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function neg(G1Point memory p) internal pure returns (G1Point memory) {\n        return G1Point(p.x, FIELD_ORDER - (p.y % FIELD_ORDER)); // p.y should already be reduced mod P?\n    }\n\n    function eq(G1Point memory p1, G1Point memory p2) internal pure returns (bool) {\n        return p1.x == p2.x && p1.y == p2.y;\n    }\n\n    function mapInto(uint256 seed) internal view returns (G1Point memory) {\n        uint256 y;\n        while (true) {\n            uint256 ySquared = fieldExp(seed, 3) + 3; // addmod instead of add: waste of gas, plus function overhead cost\n            y = fieldExp(ySquared, (FIELD_ORDER + 1) / 4);\n            if (fieldExp(y, 2) == ySquared) {\n                break;\n            }\n            seed += 1;\n        }\n        return G1Point(seed, y);\n    }\n\n    function mapInto(string memory input) internal view returns (G1Point memory) {\n        return mapInto(uint256(keccak256(abi.encodePacked(input))) % FIELD_ORDER);\n    }\n\n    function mapInto(string memory input, uint256 i) internal view returns (G1Point memory) {\n        return mapInto(uint256(keccak256(abi.encodePacked(input, i))) % FIELD_ORDER);\n    }\n\n    function slice(bytes memory input, uint256 start) internal pure returns (uint256 result) { // extracts exactly 32 bytes\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(add(add(input, 0x20), start))) // why only 0x20?\n            result := mload(m)\n        }\n    }\n}\n",
  "sourcePath": "/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.19",
  "updatedAt": "2020-01-11T00:58:17.537Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}