{
  "contractName": "Utils",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.4+commit.9549d8ff\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol\":\"Utils\"},\"evmVersion\":\"byzantium\",\"libraries\":{},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol\":{\"keccak256\":\"0x9b61721071ca5df079abe43906e41fc7a3e8da6994f974ff7d22d6e114c01938\",\"urls\":[\"bzzr://d180973b32645bdfe8d5a216020483efac70379ea0b14a55d231d29f91c15155\"]}},\"version\":1}",
  "bytecode": "0x605a602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820189f06f40bbf31dfc0b80fdc5e10e92cff5bbe6c9a4af78c1116a0e81c84f4ab6c6578706572696d656e74616cf50037",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72305820189f06f40bbf31dfc0b80fdc5e10e92cff5bbe6c9a4af78c1116a0e81c84f4ab6c6578706572696d656e74616cf50037",
  "sourceMap": "58:4911:4:-;;132:2:-1;166:7;155:9;146:7;137:37;252:7;246:14;243:1;238:23;232:4;229:33;270:1;265:20;;;;222:63;;265:20;274:9;222:63;;298:9;295:1;288:20;328:4;319:7;311:22;352:7;343;336:24",
  "deployedSourceMap": "58:4911:4:-;;;;;;;;",
  "source": "pragma solidity 0.5.4;\npragma experimental ABIEncoderV2;\n\nlibrary Utils {\n\n    uint256 constant GROUP_ORDER = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\n    uint256 constant FIELD_ORDER = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\n        return addmod(x, y, GROUP_ORDER);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulmod(x, y, GROUP_ORDER);\n    }\n\n    function inv(uint256 x) internal view returns (uint256) {\n        return exp(x, GROUP_ORDER - 2);\n    }\n\n    function mod(uint256 x) internal pure returns (uint256) {\n        return x % GROUP_ORDER;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x - y : GROUP_ORDER - y + x;\n    }\n\n    function neg(uint256 x) internal pure returns (uint256) {\n        return GROUP_ORDER - x;\n    }\n\n    function exp(uint256 base, uint256 exponent) internal view returns (uint256 output) {\n        uint256 order = GROUP_ORDER;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), 0x20)\n            mstore(add(m, 0x40), 0x20)\n            mstore(add(m, 0x60), base)\n            mstore(add(m, 0x80), exponent)\n            mstore(add(m, 0xa0), order)\n            if iszero(staticcall(gas, 0x05, m, 0xc0, m, 0x20)) { // staticcall or call?\n                revert(0, 0)\n            }\n            output := mload(m)\n        }\n    }\n\n    function fieldExp(uint256 base, uint256 exponent) internal view returns (uint256 output) { // warning: mod p, not q\n        uint256 order = FIELD_ORDER;\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), 0x20)\n            mstore(add(m, 0x40), 0x20)\n            mstore(add(m, 0x60), base)\n            mstore(add(m, 0x80), exponent)\n            mstore(add(m, 0xa0), order)\n            if iszero(staticcall(gas, 0x05, m, 0xc0, m, 0x20)) { // staticcall or call?\n                revert(0, 0)\n            }\n            output := mload(m)\n        }\n    }\n\n    struct G1Point {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    function add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(p1))\n            mstore(add(m, 0x20), mload(add(p1, 0x20)))\n            mstore(add(m, 0x40), mload(p2))\n            mstore(add(m, 0x60), mload(add(p2, 0x20)))\n            if iszero(staticcall(gas, 0x06, m, 0x80, r, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(p))\n            mstore(add(m, 0x20), mload(add(p, 0x20)))\n            mstore(add(m, 0x40), s)\n            if iszero(staticcall(gas, 0x07, m, 0x60, r, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function neg(G1Point memory p) internal pure returns (G1Point memory) {\n        return G1Point(p.x, bytes32(FIELD_ORDER - uint256(p.y))); // p.y should already be reduced mod P?\n    }\n\n    function eq(G1Point memory p1, G1Point memory p2) internal pure returns (bool) {\n        return p1.x == p2.x && p1.y == p2.y;\n    }\n\n    function g() internal pure returns (G1Point memory) {\n        return G1Point(0x077da99d806abd13c9f15ece5398525119d11e11e9836b2ee7d23f6159ad87d4, 0x01485efa927f2ad41bff567eec88f32fb0a0f706588b4e41a8d587d008b7f875);\n    }\n\n    function h() internal pure returns (G1Point memory) {\n        return G1Point(0x01b7de3dcf359928dd19f643d54dc487478b68a5b2634f9f1903c9fb78331aef, 0x2bda7d3ae6a557c716477c108be0d0f94abc6c4dc6b1bd93caccbcceaaa71d6b);\n    }\n\n    function mapInto(uint256 seed) internal view returns (G1Point memory) {\n        uint256 y;\n        while (true) {\n            uint256 ySquared = fieldExp(seed, 3) + 3; // addmod instead of add: waste of gas, plus function overhead cost\n            y = fieldExp(ySquared, (FIELD_ORDER + 1) / 4);\n            if (fieldExp(y, 2) == ySquared) {\n                break;\n            }\n            seed += 1;\n        }\n        return G1Point(bytes32(seed), bytes32(y));\n    }\n\n    function mapInto(string memory input) internal view returns (G1Point memory) {\n        return mapInto(uint256(keccak256(abi.encodePacked(input))) % FIELD_ORDER);\n    }\n\n    function mapInto(string memory input, uint256 i) internal view returns (G1Point memory) {\n        return mapInto(uint256(keccak256(abi.encodePacked(input, i))) % FIELD_ORDER);\n    }\n\n    function slice(bytes memory input, uint256 start) internal pure returns (bytes32 result) {\n        assembly {\n            let m := mload(0x40)\n            mstore(m, mload(add(add(input, 0x20), start))) // why only 0x20?\n            result := mload(m)\n        }\n    }\n}\n",
  "sourcePath": "/Users/benediamond/anonymous-zether/packages/protocol/contracts/Utils.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.19",
  "updatedAt": "2020-03-06T01:39:19.034Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}